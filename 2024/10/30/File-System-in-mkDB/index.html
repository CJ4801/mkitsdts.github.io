<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><script>window.icon_font="4552607_tq6stt6tcg",window.clipboard_tips={success:"澶嶅埗鎴愬姛(*^鈻絕*)",fail:"澶嶅埗澶辫触 (锞熲娍锞�)锞�",copyright:{enable:!1,count:50,content:"鏈枃鐗堟潈锛氭湰鍗氬鎵€鏈夋枃绔犻櫎鐗瑰埆澹版槑澶栵紝鍧囬噰鐢� BY-NC-SA 璁稿彲鍗忚銆傝浆杞借娉ㄦ槑鍑哄锛�"}}</script><title>File System in mkDB | mkitsdts</title><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin><link rel="preload" as="style" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic&display=swap"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic&display=swap" media="print" onload="this.media&#x3D;&#39;all&#39;"><link rel="preload" href="//at.alicdn.com/t/c/font_4552607_tq6stt6tcg.woff2" as="font" type="font/woff2" crossorigin="anonymous"><link rel="stylesheet" href="/css/loader.css"><meta name="description" content="文件系统是数据库相当重要的一部分，因此文件系统的设计也是非常关键的一步。 磁盘如此浩大，如何才能找到注定的那个地址呢？下面的文字记录了我对文件系统认知的深入过程。  按照innodb的设计，文件存储的方式分为在内存和外存两部分。这是一个很好的思路，下面会详细说明。  内存  外存  文件架构 前面了解到SQL语句对mysql文件的影响，在创建数据库的时候程序会相应地创建文件，每一个数据库就是一个文"><meta property="og:type" content="article"><meta property="og:title" content="File System in mkDB"><meta property="og:url" content="http://example.com/2024/10/30/File-System-in-mkDB/index.html"><meta property="og:site_name" content="mkitsdts"><meta property="og:description" content="文件系统是数据库相当重要的一部分，因此文件系统的设计也是非常关键的一步。 磁盘如此浩大，如何才能找到注定的那个地址呢？下面的文字记录了我对文件系统认知的深入过程。  按照innodb的设计，文件存储的方式分为在内存和外存两部分。这是一个很好的思路，下面会详细说明。  内存  外存  文件架构 前面了解到SQL语句对mysql文件的影响，在创建数据库的时候程序会相应地创建文件，每一个数据库就是一个文"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2024-10-30T03:53:54.000Z"><meta property="article:modified_time" content="2024-11-02T12:54:04.698Z"><meta property="article:author" content="mkitsdts"><meta property="article:tag" content="mkDB"><meta name="twitter:card" content="summary"><link rel="alternate" href="/atom.xml" title="mkitsdts" type="application/atom+xml"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/style.css"><link rel="preload" href="https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.css" as="style" onload='this.onload=null,this.rel="stylesheet"'><script src="https://npm.webcache.cn/pace-js@1.2.4/pace.min.js"></script><link rel="stylesheet" href="https://npm.webcache.cn/@reimujs/aos@0.0.1/dist/aos.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loader"><div class="loading-left-bg loading-bg"></div><div class="loading-right-bg loading-bg"></div><div class="spinner-box"><div class="loading-taichi"><svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" version="1.1" xmlns="https://www.w3.org/2000/svg" shape-rendering="geometricPrecision"><path d="M303.5 432A80 80 0 0 1 291.5 592A80 80 0 0 1 303.5 432z" fill="#ff5252"/><path d="M512 65A447 447 0 0 1 512 959L512 929A417 417 0 0 0 512 95A417 417 0 0 0 512 929L512 959A447 447 0 0 1 512 65z 
         M512 95A417 417 0 0 1 929 512A208.5 208.5 0 0 1 720.5 720.5L720.5 592A80 80 0 0 0 720.5 432A80 80 0 0 0 720.5 592L720.5 720.5A208.5 208.5 0 0 1 512 512A208.5 208.5 0 0 0 303.5 303.5A208.5 208.5 0 0 0 95 512A417 417 0 0 1 512 95z" fill="#ff5252"/></svg></div><div class="loading-word">灏戝コ绁堢シ涓�...</div></div></div><script>var time = null;
    var startLoading = () => {
      time = Date.now();
      document.getElementById('loader').classList.remove("loading");
    }
    var endLoading = () => {
      if (!time) {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
      } else {
        if (Date.now() - time > 500) {
          time = null;
          document.body.style.overflow = 'auto';
          document.getElementById('loader').classList.add("loading");
        } else {
          setTimeout(endLoading, 500 - (Date.now() - time));
          time = null;
        }
      }
    }
    window.addEventListener('DOMContentLoaded', endLoading);
    document.getElementById('loader').addEventListener('click', endLoading);</script><div id="copy-tooltip" style="pointer-events:none;opacity:0;transition:all .2s ease;position:fixed;top:50%;left:50%;z-index:999;transform:translate(-50%,-50%);color:#fff;background:rgba(0,0,0,.5);padding:10px 15px;border-radius:10px"></div><div id="container"><div id="wrap"><div id="header-nav"><nav id="main-nav"><span class="main-nav-link-wrap"><div class="main-nav-icon icon-taichi"></div><a class="main-nav-link" href="/">首页</a> </span><span class="main-nav-link-wrap"><div class="main-nav-icon icon-taichi"></div><a class="main-nav-link" href="/archives">归档</a> </span><span class="main-nav-link-wrap"><div class="main-nav-icon icon-taichi"></div><a class="main-nav-link" href="/about">关于</a> </span><span class="main-nav-link-wrap"><div class="main-nav-icon icon-taichi"></div><a class="main-nav-link" href="/friend">友链</a> </span><a id="main-nav-toggle" class="nav-icon"></a></nav><nav id="sub-nav"><a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a></nav></div><header id="header"><img fetchpriority="high" src="/images/banner.webp" alt="File System in mkDB"><div id="header-outer"><div id="header-title"><a href="/" id="logo"><h1 data-aos="slide-up">File System in mkDB</h1></a><h2 id="subtitle-wrap" data-aos="slide-down"></h2></div></div></header><div id="content"><section id="main"><article id="post-File-System-in-mkDB" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-inner" data-aos="fade-up"><div class="article-meta"><div class="article-date"><a href="/2024/10/30/File-System-in-mkDB/" class="article-date-link" data-aos="zoom-in"><time datetime="2024-10-30T03:53:54.000Z" itemprop="datePublished">2024-10-30</time> <time style="display:none" id="post-update-time">2024-11-02</time></a></div></div><div class="hr-line"></div><div class="e-content article-entry" itemprop="articleBody"><p>文件系统是数据库相当重要的一部分，因此文件系统的设计也是非常关键的一步。</p><p>磁盘如此浩大，如何才能找到注定的那个地址呢？下面的文字记录了我对文件系统认知的深入过程。</p><h2 id="按照innodb的设计文件存储的方式分为在内存和外存两部分-这是一个很好的思路下面会详细说明"><a class="markdownIt-Anchor" href="#按照innodb的设计文件存储的方式分为在内存和外存两部分-这是一个很好的思路下面会详细说明"></a> 按照innodb的设计，文件存储的方式分为在内存和外存两部分。这是一个很好的思路，下面会详细说明。</h2><h2 id="内存"><a class="markdownIt-Anchor" href="#内存"></a> 内存</h2><h2 id="外存"><a class="markdownIt-Anchor" href="#外存"></a> 外存</h2><h4 id="文件架构"><a class="markdownIt-Anchor" href="#文件架构"></a> 文件架构</h4><p>前面了解到SQL语句对mysql文件的影响，在创建数据库的时候程序会相应地创建文件，每一个数据库就是一个文件夹，每一张表就是一个文件。<br>可能有点人会想，为什么要创建这么多文件，能不能全部塞在同一个文件下？先回答是可以的，不管单文件还是多文件其实都不影响，只要能管理好就行，真正的难点是怎么存储文件。</p><p>这里我认为多文件方便逻辑梳理，所以我采用的是多文件，也就是一张表一个文件。</p><ol><li>数据库的存储结构<br>索引结构提供了高效的索引方式，索引信息和数据记录都是保存在文件上的，确切说是存储在页结构中的。</li></ol><p>索引是在存储引擎中实现的，不同存储引擎中存放的格式一般是不同的，甚至有的存储引警比如 Memory 甚至都不用磁盘来存储数据。</p><p>由于 InnoDB 是 MySQL 的默认存储引擎，所以本章剖析 InnoDB 存储引擎的数据存储结构。</p><p>1.1 磁盘与内存交互的基本单位<br>页是磁盘与内存交互的基本单位。</p><p>InnoDB 将数据划分为若干个页，InnoDB 中页的大小默认为 16KB。</p><p>以页作为磁盘和内存之间交互的基本单位，也就是一次至少从磁盘中读取 16KB 大小的内容到内存中，或者一次至少把内存中 16KB 的内容刷新到磁盘中。使用 InnoDB 不论读一行，还是读多行，都会加载这些行所在的页。</p><p>记录是按行来存储的，但读取并不以行为单位，否则一次读取（一次 IO 操作）只能处理一行数据，效率非常低。</p><p>使用 InnoDB 管理存储空间的基本单位是页（Page），数据库 IO 操作的最小单位是页。一个页可以存储多个行记录。</p><p>1.2 页结构概述<br>多个页可以不在物理结构上相连，只通过双向链表相关联即可。</p><p>每个数据页中的记录会按照主键值从小到大的顺序组成一个单向链表，每个数据页都会为存储在它里边的记录生成一个页目录。</p><p>通过主键查找某条记录时可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可。</p><p>1.3 页的大小<br>不同数据库管理系统中的页大小通常不同。MySQL 的 InnoDB 存储引擎中，默认的页大小是 16KB，可以通过以下命令查看：</p><p>PLAINTEXT<br>1<br>SHOW VARIABLES LIKE ‘%innodb_page_size%’;<br>mysql&gt; SHOW VARIABLES LIKE ‘%innodb_page_size%’;<br>±-----------------±------+<br>| Variable_name | Value |<br>±-----------------±------+<br>| innodb_page_size | 16384 |<br>±-----------------±------+<br>SQL Server 中页的大小是 8KB，Oracle 中使用 块(Block) 来代表页，它支持的块大小有 2KB、4KB、8KB、16KB、32KB 和 64KB。</p><p>1.4 页的上层结构<br>在数据库中，还存在着区（Extent）、段（Segment）和表空间（Tablespace）的概念。它们之间的关系如下图所示：</p><h1 id="区extent-是比页大一级的存储结构在-innodb-存储引擎中一个区会分配-64-个连续的页-innodb-中页大小默认是-16kb因此一个区的大小是6416kb"><a class="markdownIt-Anchor" href="#区extent-是比页大一级的存储结构在-innodb-存储引擎中一个区会分配-64-个连续的页-innodb-中页大小默认是-16kb因此一个区的大小是6416kb"></a> 区(Extent) 是比页大一级的存储结构，在 InnoDB 存储引擎中，一个区会分配 64 个连续的页。InnoDB 中页大小默认是 16KB，因此一个区的大小是<br>64<br>×<br>16<br>𝐾<br>𝐵</h1><p>1<br>𝑀<br>𝐵<br>64×16KB=1MB。</p><p>段(Segment) 由一个或多个区组成，区在文件系统是一个连续分配的空间（在 InnoDB 中是连续的 64 个页），但段中的区不一定是相邻的。 段是数据库中的分配单位 ，不同类型的数据库对象以不同的段形式存在。在创建数据表、索引时，就会创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。</p><p>表空间(Tablespace) 是一个逻辑容器，表空间中存储了段，在一个表空间中可以有若干个段，但一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理层面上可以划分为系统表空间、用户表空间、撤销表空间、临时表空间等。</p><ol start="2"><li>页的内部结构<br>按类型对页划分，常见的有：</li></ol><p>数据页（保存 B+Tree 节点）<br>系统页<br>Undo 页<br>事务数据页<br>数据页是最常使用的页。</p><p>16KB 的数据页被划分为七个部分：</p><p>文件头（File Header）<br>页头（Page Header）<br>最大最小记录（Infimum + Supremum）<br>用户记录（User Records）<br>空闲空间（Free Space）<br>页目录（Page Directory）<br>文件尾（File Tailer）</p><p>7 个部分的作用如下：</p><p>名称	占用大小	说明<br>File Header	38 字节	文件头，描述页的信息<br>Page Header	56 字节	页头，页的状态信息<br>Infimum + Supremum	26 字节	最大和最小记录，两个虚拟的行记录<br>User Records	不确定	用户记录，存储的行记录内容<br>Free Space	不确定	空闲记录，页中还没有被使用的空间<br>Page Directory	不确定	页目录，存储用户记录的相对位置<br>File Trailer	8 字节	文件尾，校验页是否完整<br>这七个部分又可以分成三类，分别是：</p><p>File Header 和 File Trailer<br>User Records、Infimum + Supremum 和 Free Space<br>Page Directory 和 Page Header<br>页的主要作用是存储记录，所以 User Records 和 Infimum + Supremum 占了页结构的主要空间：</p><p>随着页中用户记录的不断增加，空闲空间不断减少。</p><p>2.1 File Header<br>File Header，即文件头部，描述各种页的通用信息（比如页的编号、其上一页、下一页是谁等）。</p><p>大小：38 字节。</p><p>构成：</p><p>名称	占用空间大小	描述<br>FIL_PAGE_SPACE_OR_CHKSUM	4 字节	页的校验和（checksum 值）<br>FIL_PAGE_OFFSET	4 字节	页号<br>FIL_PAGE_PREV	4 字节	上一个页的页号<br>FIL_PAGE_NEXT	4 字节	下一个页的页号<br>FIL_PAGE_LSN	8 字节	页面被最后修改时对应的日志序列位置（Log Sequence Number）<br>FIL_PAGE_TYPE	2 字节	页的类型<br>FIL_PAGE_FILE_FLUSH_LSN	8 字节	仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的 LSN 值<br>FIL_PAGE_ARCH_LOG_ON_OR_SPACE_ID	4 字节	页属于哪个表空间<br>FIL_PAGE_OFFSET（4字节）</p><p>每一个页都有一个单独的页号，就像身份证号码一样，InnoDB 通过页号可以定位到唯一页。</p><p>FIL_PAGE_TYPE（2字节）</p><p>当前页的类型。</p><p>类型名称	十六进制	描述<br>FIL_PAGE_TYPE_ALLOCATED	0x0000	最新分配，还未使用<br>FIL_PAGE_UNDO_LOG	0x0002	Undo 日志页<br>FIL_PAGE_INODE	0x0003	段信息节点<br>FIL_PAGE_IBUF_FREE_LIST	0x0004	Insert Buffer 空闲列表<br>FIL_PAGE_IBUF_BITMAP	0x0005	Insert Buffer 位图<br>FIL_PAGE_TYPE_SYS	0x0006	系统页<br>FIL_PAGE_TYPE_TRX_SYS	0x0007	事务系统数据<br>FIL_PAGE_TYPE_FSP_HDR	0x0008	表空间头部信息<br>FIL_PAGE_TYPE_XDES	0x0009	扩展描述页<br>FIL_PAGE_TYPE_BLOB	0x000A	溢出页<br>FIL_PAGE_INDEX	0x45BF	索引页，即数据页<br>FIL_PAGE_PREV（4字节）和FIL_PAGE_NEXT（4字节）</p><p>InnoDB 是以页为单位存放数据的，如果数据分散到多个不连续的页中进行存储，则需要把这些页关联起来，FIL_PAGE_PREV 和 FIL_PAGE_NEXT 分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把众多页都串联起来，保证这些页之间无需物理上的连续，而达到逻辑上的连续。</p><p>FIL_PAGE_SPACE_OR_CHKSUM（4字节）</p><p>当前页面的校验和（checksum）。</p><p>什么是校验和？</p><p>对于一个很长的字节串来说，会通过某种算法来计算一个比较短的值来代表这个很长的字节串，这个比较短的值就被称为校验和。</p><p>在比较两个很长的字节串之前，先比较这两个长字节串的校验和，如果校验和都不一样，那么两个长字节串肯定是不同的，这能够省去直接比较两个比较长的字节串的时间损耗。</p><p>文件头部和文件尾部都有 FIL_PAGE_SPACE_OR_CHKSUM 属性。</p><p>FIL_PAGE_SPACE_OR_CHKSUM 的作用：</p><p>InnoDB 存储引擎以页为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。假设在同步一半时突然断电，导致该页传输得不完整。可以通过比较文件尾的校验和（checksum 值）与文件头的校验和来检测一个页是否完整（也就是在同步的时候有没有发生只同步部分的情况），如果两个值不相等，则证明页的传输有问题，需要重新传输，否则认为页的传输已经完成。</p><p>具体过程：</p><p>当一个页在内存中被修改后，在同步之前会把它的校验和算出来，由于 File Header 在页的前边，所以 File Header 的校验和会先被同步到磁盘，当完全写完时，File Trailer 的校验和会被写到页的尾部。如果完全同步成功，则页的首、尾部校验和是一致的；如果写到一半突然断电，File Header 的校验和代表已经修改过的页，File Trailer 的校验和代表原先的页，二者不同则意味着同步中间出了错。这里的校验方式采用了 Hash 算法。</p><p>FIL_PAGE_LSN（8字节）</p><p>页面被最后修改时对应的日志序列位置（Log Sequence Number）。</p><p>2.2 File Trailer<br>File Trailer，即文件尾部。</p><p>大小：8 字节。</p><p>前 4 个字节代表页的校验和，与 File Header 中的校验和相对应。</p><p>后 4 个字节代表页面被最后修改时对应的日志序列位置（LSN），这部分也是为了校验页的完整性，如果首、尾部的 LSN 值校验失败，说明在同步过程出现了问题。</p><p>2.3 Free Space<br>Free Space，即空闲空间。</p><p>存储的记录会按照指定的行格式存储到 User Records 部分。在最开始生成页的时候，并没有 User Records，每当插入一条记录，都会从 Free Space，也就是尚未使用的存储空间中申请一个记录大小的空间划分到 User Records。当 Free Space 的空间都被 User Records 替代之后，就意味着这个页使用完了，此时再插入新记录，就需要申请新的页。</p><p>2.4 User Records<br>User Records，即用户记录。</p><p>用户记录中的记录按照 指定的行格式 一条一条地摆放，相互之间形成单链表。</p><p>那其中的每条记录又是怎么记录的呢？或者说单链表又是怎么形成的？</p><p>这就需要说到 行格式 中的 记录头信息 了。</p><p>记录头信息</p><p>记录头信息占了 5 字节。</p><p>执行以下语句创建 page_demo 表，指定字符集为 ascii，指定行格式为 Compact：</p><p>SQL<br>1<br>2<br>3<br>4<br>5<br>6<br>CREATE TABLE page_demo (<br>c1 INT,<br>c2 INT,<br>c3 VARCHAR(10000),<br>PRIMARY KEY (c1)<br>) CHARSET = ascii ROW_FORMAT = Compact;<br>一条记录的行格式如下图所示：</p><p>可以看到，除了记录的真实数据外，一条记录还包括一些额外信息：</p><p>变长字段长度列表<br>NULL 值列表<br>记录头信息<br>此处主要讲述 记录头信息，在记录头信息中，又包含了多个属性：</p><p>名称	大小（单位 bit）	描述<br>预留位 1	1	未使用<br>预留位 2	1	未使用<br>delete_mask	1	标记当前记录是否被删除<br>min_rec_mask	1	B+Tree 的每层非叶子节点中的最小记录都会添加该标记<br>n_owned	4	当前记录拥有的记录数<br>heap_no	13	当前记录在记录堆的位置信息<br>record_type	3	当前记录的类型<br>next_record	16	下一条记录的相对位置<br>移除两个预留位后，行格式的简化图：</p><p>向表中插入 4 条数据：</p><p>SQL<br>1<br>2<br>3<br>4<br>5<br>INSERT INTO page_demo VALUES<br>(1, 100, ‘song’),<br>(2, 200, ‘tong’),<br>(3, 300, ‘zhan’),<br>(4, 400, ‘lisi’);<br>此时用户记录的示意图如下：</p><p>后续将围绕这 4 条数据介绍 记录头信息 中各个属性的作用。</p><p>记录头信息：delete_mask</p><p>标记当前记录是否被删除，占用 1 个二进制位：</p><p>0：记录未被删除<br>1：记录已被删除<br>当某条记录被删除后，不会立即从磁盘上移除。如果立即移除，之后的记录需要在磁盘上重新排列，造成性能消耗。所有被删掉的记录会组成一个所谓的垃圾链表，这个链表中的记录占用的空间被称为 可重用空间，当有新记录插入时，可以覆盖这些被删除的记录。</p><p>记录头信息：min_rec_mask</p><p>B+Tree 的每层 非叶子节点 中的最小记录都会添加该标记，值为1。</p><p>前面插入的四条记录的 min_rec_mask 值都是0，意味它们都不是 B+Tree 的非叶子节点中的最小记录（因为它们根本就不是非叶子节点，都是叶子节点）。</p><p>记录头信息：record_type</p><p>当前记录的类型，共有 4 种类型：</p><p>类型值	对应的记录类型<br>0	普通记录<br>1	B+Tree 非叶节点记录<br>2	最小记录<br>3	最大记录<br>前面插入的四条记录都是普通记录，因此它们的 record_type 都是 0。</p><p>记录头信息：heap_no</p><p>当前记录在本页中的位置。</p><p>前面插入的四条记录在本页中的位置分别是 2、3、4、5，怎么没有 0 或 1 的记录呢？</p><p>MySQL 会自动为每个页添加两条记录，由于这两条记录并不是用户插入的，所以也称为 伪记录 或 虚拟记录。这两个伪记录一个代表 最小记录，一个代表 最大记录。最小记录和最大记录的 heap_no 值分别是 0 和 1，也就是说它们俩在页中的位置最靠前。</p><p>什么是最大记录，什么是最小记录？参看【2.5 Infimum + Supremum】。</p><p>记录头信息：n_owned</p><p>页目录中每个组中最后一条记录的头信息中会存储该组一共有多少条记录，存储所用的字段就是 n_owned。</p><p>页目录的详细信息可以参看【2.6 Page Directory】。</p><p>记录头信息：next_record</p><p>next_record 在记录头信息中十分重要，它表示从当前记录的真实数据到 下一条 记录的真实数据的 地址偏移量。</p><p>比如第一条记录的 next_record 值为 32，意味着从第一条记录的真实数据的地址处向后找 32 个字节就是 下一条 记录的真实数据。</p><p>这里的 下一条 记录并不是按照插入顺序插入的下一条记录，而是按照主键值由小到大排列的下一条记录，同时规定 Infimum 记录（即最小记录）的下一条记录是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录是 Supremum 记录（即最大记录）。</p><p>如果从表中删除一条记录，这个单链表也会发生变化：</p><p>SQL<br>1<br>DELETE FROM page_demo WHERE c1 = 2;</p><p>删除 c1 为 2 的记录后：</p><p>被删除记录并没有立即从存储空间中移除，而是把该记录的 delete_mask 值设置为 1；<br>被删除记录的 next_record 值为 0，表示该记录没有下一条记录；<br>被删除记录的前一条记录的 next_record 指向了被删除记录的下一条记录；<br>最大记录的 n_owned 值从 5 变成了 4。<br>不论怎么对页中的记录做增删改操作，InnoDB 始终会维护一条记录的单链表，链表中的各个节点按照主键值由小到大的顺序进行连接。</p><p>如果又添加一条 c1 为 2 的记录呢？</p><p>直接复用了被删除记录的存储空间。</p><p>如果数据页中存在多条被删除掉的记录，这些记录的 next_record 会链接起来，并组成一个垃圾链表，以便后续重用这些存储空间。</p><p>2.5 Infimum + Supremum<br>Infimum，即最小记录；Supremum，即最大记录。</p><p>记录也可以比大小。对于一条完整的记录来说，比较记录的大小就是比较主键的大小。比如插入的 4 条记录的主键值分别是 1、2、3、4，这意味着这 4 条记录是从小到大依次递增。</p><h1 id="innodb-规定的最小记录与最大记录的构造十分简单都由-5-字节的记录头信息和-8-字节大小的一个固定的部分组成一条占58"><a class="markdownIt-Anchor" href="#innodb-规定的最小记录与最大记录的构造十分简单都由-5-字节的记录头信息和-8-字节大小的一个固定的部分组成一条占58"></a> InnoDB 规定的最小记录与最大记录的构造十分简单，都由 5 字节的记录头信息和 8 字节大小的一个固定的部分组成（一条占<br>5<br>+<br>8</h1><p>13<br>5+8=13 字节，俩一起就 26 字节）：</p><p>这两条记录不是用户定义的记录，它们并不存放在页的 User Records 中，而是被单独放在一个称为 Infimum + Supremum 的部分：</p><p>2.6 Page Directory<br>Page Directory，即页目录。</p><p>在页中，记录以单向链表的形式进行存储的。单向链表的插入、删除效率高，但检索效率不高，最坏情况需要遍历链表上的所有节点才能完成检索。因此在页结构中专门设计了页目录这个模块，使得能够通过二分查找法的方式对记录进行检索。</p><p>现在需要查找 page_demo 表中 c1 为 3 的记录，如果使用页目录进行二分查找：</p><p>将所有记录分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；<br>第 1 组中 只有 最小记录；最后一组是最大记录所在的分组，内部会有 1~8 条记录；其余组中记录的数量在 4~8 条之间。这样使得除第 1 组（最小记录所在组）外，其余组的记录数会尽量平分。<br>每个组中最后一条记录的头信息（其中的 n_owned）中会存储该组一共有多少条记录；<br>页目录会存储每组最后一条记录的地址偏移量，这些地址偏移量按照先后顺序排列，每组的地址偏移量也被称为槽（slot），每个槽相当于指针指向了不同组的最后一个记录。</p><p>比如 page_demo 表中共有 6 条记录，InnoDB 会把它们分成两组，第一组中只有一条最小记录，第二组中含有剩余的 5 条记录：</p><p>由上图可知：</p><p>页目录中只有两个槽，也就是说记录被分为了两组，槽 1 中的值是 112，表示最大记录的地址偏移量（从页面的 0 字节开始数，数 112 个字节）；槽 0 中的值是 99，代表最小记录的地址偏移量。<br>最小记录的 n_owned 值为1，表示以最小记录结尾的这个分组中只有 1 条记录，即最小记录本身。<br>最大记录的 n_owned 值为 5，表示以最大记录结尾的这个分组中有 5 条记录，除最大记录外，还有用户插入的 4 条记录。<br>如果将槽与记录链接起来：</p><p>将记录的分组也体现出来：</p><p>页目录的分组个数是如何确定的？</p><p>InnoDB 规定：对于最小记录所在的分组 只能 有 1 条记录，最大记录所在的分组拥有的记录条数 只能 在 1~8 条之间，剩下分组中记录的条数范围 只能 在是 4~8 条之间。</p><p>分组过程将按照：</p><p>初始情况下一个数据页中只有最小记录和最大记录，它们分属于两个分组；</p><p>每插入一条用户记录，都会从页目录中找到主键值比插入记录的主键值大且差值最小的槽，然后把该槽中最后一条记录的 n_owned 值加 1，表示本组内添加了一条记录，直到该组中的记录数等于 8；</p><p>当一个组中的记录数为 8 时再插入一条记录，会将组中的记录拆分为两个组，一个组 4 条，另一个 5 条，并在页目录中新增一个槽来记录新增分组中最大记录的地址偏移量。</p><p>如何使用页目录进行快速查找到目标记录</p><h1 id="向-page_demo-表中再增加-12-条记录现在共有612"><a class="markdownIt-Anchor" href="#向-page_demo-表中再增加-12-条记录现在共有612"></a> 向 page_demo 表中再增加 12 条记录，现在共有<br>6<br>+<br>12</h1><p>18<br>6+12=18 条记录（包括最大、最小记录），这些记录被分为 5 个组：</p><p>各个槽中代表的记录的主键值按照从小到大排序，所以才可以使用二分法来快速查找。5 个槽的编号分别是 0、1、2、3、4，所以初始情况下最低的槽是 low = 0，最高的槽是 high = 4。如果想查找主键值为 6 的记录：</p><h1 id="计算中间槽的位置为042"><a class="markdownIt-Anchor" href="#计算中间槽的位置为042"></a> 计算中间槽的位置为<br>(<br>0<br>+<br>4<br>)<br>÷<br>2</h1><p>2<br>(0+4)÷2=2，槽 2 对应记录的主键值为 8，又因为<br>8</p><blockquote></blockquote><h1 id="686设置-high-为-2low-保持不变重新计算中间槽的位置为022"><a class="markdownIt-Anchor" href="#686设置-high-为-2low-保持不变重新计算中间槽的位置为022"></a> 6<br>8&gt;6，设置 high 为 2，low 保持不变；<br>重新计算中间槽的位置为<br>(<br>0<br>+<br>2<br>)<br>÷<br>2</h1><h1 id="10221槽-1-对应的主键值为-4又因为4646设置-low-为-1high-保持不变由于highlow"><a class="markdownIt-Anchor" href="#10221槽-1-对应的主键值为-4又因为4646设置-low-为-1high-保持不变由于highlow"></a> 1<br>(0+2)÷2=1，槽 1 对应的主键值为 4，又因为<br>4<br>&lt;<br>6<br>4&lt;6，设置 low 为 1，high 保持不变；<br>由于<br>ℎ<br>𝑖<br>𝑔<br>ℎ<br>−<br>𝑙<br>𝑜<br>𝑤</h1><p>1<br>high−low=1，确定主键值为 6 的记录在槽 2 对应的组中，接下来需要找到槽 2 中主键值最小的那条记录，然后沿着单向链表遍历槽 2 中的记录。<br>每个槽对应该组中主键值最大的记录，槽 2 对应主键值为 8 的记录，怎么定位一个组中最小的记录呢？</p><p>各个槽都是挨着的，可以很轻易的拿到槽 1 对应的记录（主键值为 4），该条记录的下一条记录就是槽 2 中主键值最小的记录，该记录的主键值为 5。可以从主键值为 5 的记录出发，遍历槽 2 中的各条记录，直到找到主键值为 6 的记录。</p><p>因为一个组中包含的记录条数范围是 1~8，所以遍历一个组中的记录的代价是很小的。</p><p>2.7 Page Header<br>Page Header，即页面头部。</p><p>为了得到数据页中记录的状态信息，比如已经存储了多少条记录、第一条记录的地址是什么、页目录中存储了多少个槽等等，特意在页中定义了名为 Page Header 的部分，Page Header 固定占用 56 个字节，专门存储各种状态信息。</p><p>名称	大小（单位 bit）	描述<br>PAGE_N_DIR_SLOTS	2	当前页目录中的槽数<br>PAGE_HEAP_TOP	2	还未使用的空间最小地址，该地址之后就是 Free Space<br>PAGE_N_HEAP	2	当前页中记录的数量（包括最大、最小、被删除的记录）<br>PAGE_FREE	2	第一个已经标记为删除的记录的地址（多个被删除的记录会通过 next_record 组成垃圾链表）<br>PAGE_GARBAGE	2	已删除记录占用的字节数<br>PAGE_LAST_INSERT	2	最后插入记录的位置<br>PAGE_DIRECTION	2	记录插入的方向<br>PAGE_N_DIRECTION	2	一个方向连续插入的记录数量<br>PAGE_N_RECS	2	当前页中记录的数量（不包括最大、最小、被删除的记录）<br>PAGE_MAX_TRX_ID	8	修改当前页的最大事务 ID，仅在二级索引中定义<br>PAGE_LEVEL	2	当前页在 B+Tree 中所处的层级<br>PAGE_INDEX_ID	8	索引 ID，表示当前页属于哪个索引<br>PAGE_BTR_SEG_LEAF	10	B+Tree 叶子段的头部信息，仅在 B+Tree 的 Root 页中定义<br>PAGE_BTR_SEG_TOP	10	B+Tree 非叶子段的头部信息，仅在 B+Tree 的 Root 页中定义<br>PAGE_DIRECTION</p><p>如果新插入记录的主键值比上一条记录的主键值大，就说这条记录的插入方向是向右，反之向左。用来表示最后一条记录插入方向的状态就是 PAGE_DIRECTION。</p><p>PAGE_N_DIRECTION</p><p>如果连续几次插入的新记录的方向都是一致的，InnoDB 会把沿着同一个方向插入记录的条数记下来，并用 PAGE_N_DIRECTION 表示。如果最后一条记录的插入方向发生了改变，这个值会被清零并重新统计。</p><p>2.8 从数据页的角度看 B+Tree 的查询<br>一棵 B+Tree 按照节点类型可以分成两部分：</p><p>叶子节点，B+Tree 最底层的节点，节点的高度为 0，存储行记录；<br>非叶子节点，节点高度大于 0，存储索引键和页面指针，并不存储行记录本身<br>B+Tree 如何进行记录检索的？</p><p>先从 B+Tree 的根开始，逐层检索，直到找到叶子节点，也就是找到对应的数据页为止，然后将数据页加载到内存中，页目录中的槽（slot）采用二分查找的方式先找到一个粗略的记录分组，最后在分组中通过链表遍历的方式查找到记录。</p><p>普通索引和唯一索引在查询效率上有什么不同？</p><p>唯一索引是在普通索引的基础上增加了约束性，即关键字唯一，找到了关键字就会停止检索。</p><p>使用普通索引时，用户记录中可能会存在多个关键字相同的情况，根据页结构，在读取一条记录时，不会单独从磁盘中读一条记录出去，而是将这个记录所在的页都加载到内存中进行读取。InnoDB 存储引擎的页大小为 16KB，一个页中可能存储着许多记录，因此在使用普通索引进行查找时，也只是在内存中多几次“判断下一条记录”的操作，对 CPU 来说，这些操作消耗的时间是忽略不计的。</p><p>所以对一个索引字段进行检索，无论采用普通索引还是唯一索引，在检索效率上几乎没有区别。</p><ol start="3"><li>InnoDB 行格式<br>向表中插入记录时，都是以行为单位的，这些记录在磁盘上的存放方式也被称为 行格式 或 记录格式。InnoDB 存储引擎设计了 4 种不同类型的行格式：</li></ol><p>Compact<br>Redundant<br>Dynamic 和 Compressed<br>在 MySQL 8.0 中可以使用以下语句查看默认的行格式：</p><p>PLAINTEXT<br>1<br>SELECT @@innodb_default_row_format;<br>mysql&gt; SELECT @@innodb_default_row_format;<br>±----------------------------+<br>| @@innodb_default_row_format |<br>±----------------------------+<br>| dynamic |<br>±----------------------------+<br>还可以使用如下语句查看某个具体表使用的行格式：</p><p>PLAINTEXT<br>1<br>SHOW TABLE STATUS like ‘表名’\G<br>在创建表时，也可以指定行格式：</p><p>PLAINTEXT<br>1<br>CREATE TABLE 表名(列的信息) ROW_FORMAT = 行格式名称<br>也能修改某个表的行格式：</p><p>PLAINTEXT<br>1<br>ALTER TABLE 表名 ROW_FORMAT = 行格式名称<br>3.1 COMPACT<br>在 MySQL 5.1 中，默认行格式为 Compact。</p><p>一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分。</p><p>由上图可知，Compact 行格式分为四个部分：</p><p>变长字段长度列表<br>NULL 值列表<br>记录头信息<br>真实记录数据<br>其中的 记录头信息 在前文已经介绍过，本节不再赘述。</p><p>变长字段长度列表</p><p>MySQL 支持一些变长的数据类型，比如 VARCHAR(M)、VARBINARY(M)、TEXT、BLOB 等类型，这些数据类型修饰列被称为变长字段，变长字段存储的字节数是不固定的，所以在存储真实数据时需要顺便把这些数据占用的字节数也存起来。在 Compact 行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表。</p><p>注意： 存储的变长长度和字段顺序是反过来的。比如两个 CARCHAR 字段在表结构的顺序是 a(10) 和 b(15)，那么在变长字段长度列表中存储的顺序是 15 和 10。</p><p>假设 record_test_table 表中的 col1、col2 和 col4 列的类型都是 VARCHAR(8)，并且均能为 NULL，所以这三个列的值的长度都需要保存在 变长字段长度列表 中。再假设这三列的内容长度以十六进制表示如下表：</p><p>字段名	内容长度<br>col1	0x08<br>col2	0x04<br>col3	0x06<br>这些长度值需要按照列顺序的 逆序 存放，最终该记录的 变长字段长度列表 值为 060408。</p><p>NULL 值列表</p><p>Compact 行格式会把可以为 NULL 的列统一管理起来，并存放在 NULL值列表 中。如果表中的列都要求 NOT NULL，那么 NULL 值列表 也不存在了。</p><p>为什么要定义 NULL 值列表？</p><p>因为数据都需要对齐，如果没有标注出 NULL 值的位置，就有可能在查询数据时出现混乱。如果使用一个特定的符号放到相应的数据位表示 NULL，虽能达到效果，但会浪费空间。所以不如开辟出一块空间专门用来记录该行的哪些列是非空数据，哪些是空数据：</p><p>二进制位值为 1 时，代表该列为 NULL<br>二进制位值为 0 时，代表该列不为 NULL<br>假设有字段 a、b、c，其中 a 是主键，在某一行中存储的数依次是 (1, null, 2)。Compact 行格式中的 NULL 值列表中将会存放 01，第一个 0 表示列 c 不为 NULL，第二个 1 表示列 b 的值为 NULL。因为列 a 是主键，肯定是非 NULL 且唯一的，因此 NULL 值列表会自动跳过主键。</p><p>因为 NULL 值列表的存在，在 Compact 行格式下，无论是定长的 CHAR，还是变长的 VARCHAR，NULL 值都不会占用任何存储空间。</p><p>记录的真实数据</p><p>记录的真实数据除了用户定义的数据以外，还会有三个隐藏列：</p><p>列名	是否必须	占用空间	描述<br>DB_ROW_ID	否	6 字节	行 ID，唯一标识<br>DB_TRX_ID	是	6 字节	事务 ID<br>DB_ROLL_PTR	是	7 字节	回滚指针<br>如果一个表没有手动定义主键列，会选取一个唯一列作为主键列；如果没有唯一列，则会为表默认添加一个名为 DB_ROW_ID 的隐藏列作为主键列。也就是说，DB_ROW_ID 隐藏列是在既没有主键列也唯一列时才会存在的。</p><p>DB_TRX_ID 和 DB_ROLL_PTR 与 MySQL 的事务日志有关，此处暂不介绍。</p><p>3.2 行溢出<br>InnoDB 存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外。</p><p>VARCHAR(M) 类型最多可以存放 65535 个字节，那可以创建仅包含一个 VARCHAR(65535) 列的表吗？比如：</p><p>PLAINTEXT<br>1<br>2<br>3<br>CREATE TABLE varchar_size_demo(<br>c VARCHAR(65535)<br>) CHARSET=ascii ROW_FORMAT=Compact;<br>ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. This includes storage overhead, check the manual. You have to change some columns to TEXT or BLOBs<br>创建失败了，这是因为：MySQL 对一条记录占用的最大存储空间是有限制的，除 BLOB 或 TEXT 类型的列外， 其他所有列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节。</p><h1 id="变长字段长度列表要占用-2-个字节且-c-列未被标记为-not-null因此-null-值列表还会占用-1-个字节最终自能创建出6553521"><a class="markdownIt-Anchor" href="#变长字段长度列表要占用-2-个字节且-c-列未被标记为-not-null因此-null-值列表还会占用-1-个字节最终自能创建出6553521"></a> 变长字段长度列表要占用 2 个字节，且 c 列未被标记为 NOT NULL，因此 NULL 值列表还会占用 1 个字节，最终自能创建出<br>65535<br>−<br>2<br>−<br>1</h1><p>65532<br>65535−2−1=65532 个字节的 VARCHAR：</p><p>PLAINTEXT<br>1<br>2<br>3<br>CREATE TABLE varchar_size_demo(<br>c VARCHAR(65532)<br>) CHARSET=ascii ROW_FORMAT=Compact;<br>注意： 此处的 65532 还和表使用的字符集有关，创建的表使用的字符集是 ascii，在这种字符集下，一个字符恰好占用 1 个字节，如果换用其他字符集，比如 utf8mf4，在这种字符集下，一个字符不再只占用 1 个字节，此时需要额外的计算才能求出 VARCHAR(M) 中 M 的最大值。</p><p>一个页的大小一般是 16KB，即 16384 字节，而一个 VARCHAR(M) 类型的列可以存储远超这个值的字节数，这导致一个页可能都存放不了一条记录，这种现象被称为 行溢出。</p><p>使用 Compact 或 Reduntant 行格式时，对于占用存储空间非常大的列，在记录的真实数据处 只会 存储该列的一部分数据，而把剩余数据分散存储到其他的几个页中，并在记录的真实数据处用 20 个字节指向这些页的地址（这 20 个字节中还包括这些分散在其他页面中的数据所占用的字节数），以便找到剩余数据所在的页，这被称为 页的拓展。</p><p>3.3 Dynamic 和 Compressed<br>在 MySQL 8.0 中，默认行格式是 Dynamic。Dynamic、Compressed 行格式和 Compact 行格式很类似，只不过在处理行溢出数据时有差别：</p><p>Compressed 和 Dynamic 两种行格式对于存放在 BLOB 中的数据采用了 完全的行溢出。在数据页中只存放 20 个字节的指针（溢出页的地址），实际的数据都存放在 Off Page（溢出页）中。</p><p>Compact 和 Redundant 两种格式会在记录的真实数据处存储一部分数据（存放 768 个前缀字节）。</p><p>对于 Compressed 行格式来说，存储在其中的行数据会以 zlib 的算法进行压缩，因此对于 BLOB、TEXT、VARCHAR 这类大长度类型的数据能够进行非常有效的存储。</p><p>3.4 Redundant<br>Redundant 是 MySQL 5.0 之前 InnoDB 的行记录存储方式，MySQL 8.0 也支持这种行格式。</p><p>不同于 Compact 行记录格式，Redundant 行格式的首部存在一个 字段长度偏移列表，它同样是按照列的顺序 逆序 摆放的。</p><p>字段长度偏移列表</p><p>Compact 行格式开头是 变长字段长度列表，而 Redundant 行格式的开头是 字段长度偏移列表，它们相比有以下差异：</p><p>少了“变长”两个字。Redundant 行格式会把该条记录中所有列（包括隐藏列）的长度信息 都 逆序存储到字段长度偏移列表。<br>多了“偏移”两个字。这意味着计算列值长度的方式不像 Compact 行格式那么直观，它采用两个相邻数值的差值来计算出各个列值的长度。<br>比如某条记录的字段长度偏移列表是：</p><p>2B 25 1F 1B 13 0C 06<br>由于采用逆序摆放，因此 字段长度偏移列表 中的值是：</p><p>06 0C 13 17 1A 24 25<br>而按照两个相邻数值的差值来计算各个列值的长度的意思是：</p><p>第一列 DB_ROW_ID 的长度是<br>0<br>𝑥<br>06<br>0x06 个字节，也就是 6 个字节。</p><p>第二列 DB_TRX_ID 的长度是<br>0<br>𝑥<br>0<br>𝐶<br>−<br>0<br>𝑥<br>06<br>0x0C−0x06 个字节，也就是 6 个字节。</p><p>第三列 DB_ROLL_PTR 的长度就是<br>0<br>𝑥<br>13<br>−<br>0<br>𝑥<br>0<br>𝐶<br>0x13−0x0C 个字节，也就是 7 个字节。</p><p>第四列 col1 的长度是<br>0<br>𝑥<br>1<br>𝐵<br>−<br>0<br>𝑥<br>13<br>0x1B−0x13 个字节，也就是 8 个字节。</p><p>第五列 col2 的长度是<br>0<br>𝑥<br>1<br>𝐹<br>−<br>0<br>𝑥<br>1<br>𝐵<br>0x1F−0x1B 个字节，也就是 4 个字节。</p><p>第六列 col3 的长度是<br>0<br>𝑥<br>25<br>−<br>0<br>𝑥<br>1<br>𝐹<br>0x25−0x1F 个字节，也就是 6 个字节。</p><p>第七列 col4 的长度是<br>0<br>𝑥<br>2<br>𝐵<br>−<br>0<br>𝑥<br>25<br>0x2B−0x25 个字节，也就是 6 个字节。</p><p>记录头信息</p><p>不同于 Compact 行格式，Redundant 行格式中的记录头信息固定占用 6 个字节（即 48 位）：</p><p>名称	大小（bit）	描述<br>()	1	预留位，未使用<br>()	1	预留位，未使用<br>deleted_mask	1	该行是否被删除<br>min_rec_mask	1	B+Tree 的每层非叶子节点中的最小记录会添加此标记<br>n_owned	4	当前记录拥有的记录数<br>heap_no	13	索引堆中该记录的位置信息<br>n_fileds	10	记录中列的数量<br>1byte_offs_flag	1	字段长度偏移列表中每个列对应的偏移量<br>next_record	16	页中下一条记录的绝对位置<br>与 Compact 行格式的记录头信息相比，有两处不同：</p><p>Redundant 行格式多了 n_field 和 1byte_offs_flag 两个属性<br>Redundant 行格式中没有 record_type 属性<br>4. 区、段、碎片区<br>4.1 为什么要有区？<br>B+Tree 的每一层中的页都会形成一个双向链表，如果是以页为单位来分配存储空间，双向链表相邻的两个页之间的物理位置可能相距非常远。</p><p>B+Tree 索引的范围查询只需要定位到最左边和最右边的记录，然后沿着双向链表一直扫描就可以了，如果链表中相邻的两个页的物理位置相距非常远，范围查询时将使用随机 IO。磁盘的速度和内存的速度差了好几个数量级，随机 IO 是非常慢的，所以应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询时才可以使用所谓的顺序 IO。</p><h1 id="一个区是在物理位置上连续的-64个页-因为-innodb-中页的大小默认为-16kb所以一个区的大小是6416kb"><a class="markdownIt-Anchor" href="#一个区是在物理位置上连续的-64个页-因为-innodb-中页的大小默认为-16kb所以一个区的大小是6416kb"></a> 一个区是在物理位置上连续的 64个页。因为 InnoDB 中页的大小默认为 16KB，所以一个区的大小是<br>64<br>×<br>16<br>𝐾<br>𝐵</h1><p>1<br>𝑀<br>𝐵<br>64×16KB=1MB。</p><p>如果表中的数据量较大，为某个索引分配空间时将不再以页为单位进行分配，而是按照区为单位，如果表中的数据特别多，甚至可以一次性分配多个连续的区。虽然这可能造成空间的浪费（数据不足以填充满整个区），但从性能的角度看，这可以消除很多随机 IO，功大于过。</p><p>4.2 为什么要有段？<br>范围查询其实是对 B+Tree 叶子节点中的记录进行顺序扫描，如果不区分叶子节点和非叶子节点，把节点代表的页面都放到申请到的区中的话，范围扫描的效果就大打折扣了（还会扫描非叶子节点）。所以 InnoDB 对 B+Tree 的叶子节点和非叶子节点进行了区别对待，叶子节点有自己独有的区，非叶子节点也有自己独有的区，存放叶子节点的区的集合就是一个 段（segment），存放非叶子节点的区的集合也是一个段，也就是说一个索引会生成 2 个段，一个时叶子节点段，另一个非叶子节点段。</p><p>除了索引的叶子节点段和非叶子节点段之外，InnoDB 中还有为存储一些特殊的数据而定义的段，比如回滚段，常见的段有数据段、索引段和回滚段。数据段即 B+Tree 的叶子节点，索引段即 B+Tree 的非叶子节点。</p><p>在 InnoDB 存储引警中，段的管理都是由引擎自身所完成，DBA 不能、也没有必要对其进行控制，某种意义上简化了 DBA 的管理。</p><p>段其实不对应表空间中某个连续的物理区域，而是一个逻辑上的概率，由若干个零散的页面以及一些完整的区组成。</p><p>4.3 为什么要有碎片区？<br>默认情况下，一个使用 InnoDB 存储引擎的表只有一个聚簇索引，一个索引会生成 2 个段，段以区为单位申请存储空间，一个区默认占 1M 的存储空间，因此默认情况下一个只存了几条记录的小表也需要 2M 的存储空间吗？以后每次添加一个索引都要多申请 2M 的存储空间吗？显然不是这样的。</p><p>目前为止介绍的区都是纯粹的，一个区被整个分配到某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在，即使段中的数据填不满区中所有的页面，余下的页面也不会挪作他用。</p><p>为了考虑上述情况，InnoDB 提出了 碎片区(fragment) 的概念。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，碎片区中的页可以用于不同的目的，比如某些页用于段 A，某些页用于段 B，甚至可能不属于任何段。</p><p>碎片区直属于表空间，不属于任何段。</p><p>为某个段分配存储空间的策略应该是：</p><p>在刚向表中插入数据时，段从某个碎片区以单个页面为单位进行存储空间的分配<br>当某个段已经占用了 32 个碎片区页面后，申请以完整的区为单位来分配存储空间<br>段不能仅定义为某些区的集合，更精确的应该是某些零散的页面以及一些完整的区的集合。</p><p>4.4 区的分类<br>区大体上可以分为 4 种类型：</p><p>空闲的区（FREE）：现在还没有用到这个区中的任何页面<br>有剩余空间的碎片区（FREE_FRAG）：碎片区中还有可用的页面<br>没有剩余空间的碎片区（FULL_FRAG）：碎片区中的所有页面都被使用，没有空闲页面<br>附属于某个段的区（FSEG）：每一个索引都可以分为叶子节点段和非叶子节点段<br>处于 FREE、FREE_FRAG 以及 FULL_FRAG 这三种状态的区都是独立的，直属于表空间；而处于 FSEG 状态的区是附属于某个段的。</p><p>如果把表空间比作成一个集团军，段就相当于师，区相当于团。一般的团都隶属于某个师，就像是处于 FSEG 的区全都隶属于某个段，而处于 FREE、FREE_FRAG 以及 FULL_FRAG 这三种状态的区却直接隶属于表空间，类似独立团直接听命于军部。</p><ol start="5"><li>表空间<br>表空间可以看做是 InnoDB 存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。</li></ol><p>表空间是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。表空间数据库由一个或多个表空间组成，表空间从管理上可以划分为：</p><p>系统表空间（System Tablespace）</p><p>独立表空间（File-per-table Tablespace）</p><p>撤销表空间（Undo Tablespace）</p><p>临时表空间（Temporary Tablespace）等</p><p>5.1 独立表空间<br>独立表空间，即每张表都有一个独立的表空间，也就是数据和索引信息都会保存在自己的表空间中。独立的表空间（即单表）可以在不同的数据库之间进行迁移。</p><p>空间可以回收（DROP TABLE 操作可自动回收表空间；其他情况，表空间不能自己回收）。如果对于统计分析或日志表，删除大量数据后可以通过 ALTER TABLE table_name ENGINE=InnoDB; 回收不用的空间。对于使用独立表空间的表，不管怎么删除，表空间的碎片都不会太严重影响性能，且还有机会处理。</p><p>独立表空间由段、区、页组成。</p><p>真实表空间对应的文件大小</p><p>到数据目录里看，会发现一个新建的表对应的 .ibd 文件只占用了 96K（仅在 MySQL 5.7 中，因为 MySQL 8.0 中还保存了表结构，.frm 文件也融入到 .idb 文件中了），仅 6 个页面大小，这是因为一开始表里边都没有数据。.ibd 文件是自扩展的，随着表中数据的增多，表空间对应的文件也会逐渐增大。</p><p>查看 InnoDB 的表空间类型</p><p>PLAINTEXT<br>1<br>SHOW VARIABLES LIKE ‘innodb_file_per_table’;<br>mysql&gt; SHOW VARIABLES LIKE ‘innodb_file_per_table’;<br>±----------------------±------+<br>| Variable_name | Value |<br>±----------------------±------+<br>| innodb_file_per_table | ON |<br>±----------------------±------+<br>Value 为 ON，这意味着每张表都会单独保存为一个 .idb 文件。</p><p>5.2 系统表空间<br>系统表空间的结构和独立表空间基本类似，只不过整个 MySQL 进程只有一个系统表空间，相比于独立表空间，在系统表空间中会额外记录一些有关整个系统信息的页面。</p><p>每向一个表中插入一条记录，MySQL 还会有如下的校验过程：</p><p>校验插入语句对应的表是否存在、插入的列和表中的列是否相符合等语法</p><p>判断插入表的聚族索引和所有二级索引对应的根页面是哪个表空间的哪个页面，然后把记录插入对应索引的 B+Tree 中</p><p>所以说，MySQL 除了保存着插入的用户数据之外，还需要保存许多额外的信息，比如：</p><p>某个表属于哪个表空间，表内有多少个列<br>表中的每个列是什么类型<br>表中有多少个索引，每个索引对应哪几个字段，该索引对应的根页面在哪个表空间的哪个页面<br>表中有多少个外键，外键都对应了哪些列<br>某个表空间对应文件系统上的文件路径是什么<br>…<br>上述这些数据并不是用户使用 INSERT 语句插入的用户数据，实是为了更好地管理用户数据而不得不引入的额外数据，这些数据也被称为 元数据。InnoDB 存储引擎特意定义了一些列的内部系统表（Internal System Table）来记录这些元数据：</p><p>表名	描述<br>SYS_TABLES	整个 InnoDB 存储引擎中所有的 表 的信息<br>SYS_COLUMNS	整个 InnoDB 存储引擎中所有的 列 的信息<br>SYS_INDEXES	整个 InnoDB 存储引擎中所有的 索引 的信息<br>SYS_FIELDS	整个 InnoDB 存储引擎中所有的 索引对应的列 的信息<br>SYS_FOREIGN	整个 InnoDB 存储引擎中所有的 外键 的信息<br>SYS_FOREIGN_COLS	整个 InnoDB 存储引擎中所有的 外键对应的列 的信息<br>SYS_TABLESPACES	整个 InnoDB 存储引擎中所有的 表空间 信息<br>SYS_DATAFILES	整个 InnoDB 存储引擎中所有的 表空间对应文件系统的文件路径 信息<br>SYS_VIRTUAL	整个 InnoDB 存储引擎中所有的 虚拟生成的列 信息<br>这些系统表也被称为 数据字典，它们都以 B+Tree 的形式保存在系统表空间的某些页面中，其中 SYS_TABLES、SYS_COLUMNS、SYS_INDEXES 和 SYS_FIELDS 这四个表尤为重要，称之为 基本系统表（Basic System Tables）。</p><p>注意： 用户不能直接访问 InnoDB 的内部系统表，除非直接去解析系统表空间对应文件系统上的文件。不过考虑到查看这些表的内容可能有助于分析问题，所以在系统数据库 information_schema 中提供了一些以 INNODB_SYS 开头的表：</p><p>mysql&gt; USE information_schema;<br>Reading table information for completion of table and column names<br>You can turn off this feature to get a quicker startup with -A</p><p>Database changed<br>mysql&gt; SHOW TABLES LIKE ‘INNODB_SYS%’;<br>Empty set (0.00 sec)</p><p>mysql&gt; SHOW TABLES LIKE ‘INNODB%’;<br>±---------------------------------------+<br>| Tables_in_information_schema (INNODB%) |<br>±---------------------------------------+<br>| INNODB_BUFFER_PAGE |<br>| INNODB_BUFFER_PAGE_LRU |<br>| INNODB_BUFFER_POOL_STATS |<br>| INNODB_CACHED_INDEXES |<br>| INNODB_CMP |<br>| INNODB_CMPMEM |<br>| INNODB_CMPMEM_RESET |<br>| INNODB_CMP_PER_INDEX |<br>| INNODB_CMP_PER_INDEX_RESET |<br>| INNODB_CMP_RESET |<br>| INNODB_COLUMNS |<br>| INNODB_DATAFILES |<br>| INNODB_FIELDS |<br>| INNODB_FOREIGN |<br>| INNODB_FOREIGN_COLS |<br>| INNODB_FT_BEING_DELETED |<br>| INNODB_FT_CONFIG |<br>| INNODB_FT_DEFAULT_STOPWORD |<br>| INNODB_FT_DELETED |<br>| INNODB_FT_INDEX_CACHE |<br>| INNODB_FT_INDEX_TABLE |<br>| INNODB_INDEXES |<br>| INNODB_METRICS |<br>| INNODB_SESSION_TEMP_TABLESPACES |<br>| INNODB_TABLES |<br>| INNODB_TABLESPACES |<br>| INNODB_TABLESPACES_BRIEF |<br>| INNODB_TABLESTATS |<br>| INNODB_TEMP_TABLE_INFO |<br>| INNODB_TRX |<br>| INNODB_VIRTUAL |<br>±---------------------------------------+<br>31 rows in set (0.01 sec)<br>注意： MySQL 8.0 中无需末尾的 SYS，否则查不出数据。</p><p>在 information_schema 数据库中的以 INNODB_SYS 开头的表并不是真正的内部系统表，而是在存储引警启动时读取这些以 SYS 开头的系统表后填充到这些表中的。它们中的字段并不完全一样，但供日常参考已经足矣。</p><p>作者: 默烦<br>链接: <a target="_blank" rel="noopener" href="https://mofan212.github.io/posts/MySQL-Advanced-Seventh-Data-Storage-Structure-Of-InnoDB/">https://mofan212.github.io/posts/MySQL-Advanced-Seventh-Data-Storage-Structure-Of-InnoDB/</a><br>来源: Mofan<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></div><footer class="article-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item" data-aos="zoom-in"><a class="article-tag-list-link" href="/tags/mkDB/" rel="tag">mkDB</a></li></ul></footer></div><nav id="article-nav" data-aos="fade-up"><div class="article-nav-link-wrap article-nav-link-left"><img data-src="/images/banner.webp" data-sizes="auto" alt="Connect to MySql" class="lazyload"> <a href="/2024/10/30/Connect-to-Mysql/"></a><div class="article-nav-caption">前一篇</div><h3 class="article-nav-title">Connect to MySql</h3></div><div class="article-nav-link-wrap article-nav-link-right"><img data-src="/images/banner.webp" data-sizes="auto" alt="Introduction of mkDB" class="lazyload"> <a href="/2024/10/30/Introduction-of-mkDB/"></a><div class="article-nav-caption">后一篇</div><h3 class="article-nav-title">Introduction of mkDB</h3></div></nav></article></section><aside id="sidebar"><div class="sidebar-wrapper wrap-sticky"><div class="sidebar-wrap" data-aos="fade-up"><div class="sidebar-toc-sidebar"><div class="sidebar-toc"><h3 class="toc-title">文章目录</h3><div class="sidebar-toc-wrapper toc-div-class"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%89%E7%85%A7innodb%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E5%88%86%E4%B8%BA%E5%9C%A8%E5%86%85%E5%AD%98%E5%92%8C%E5%A4%96%E5%AD%98%E4%B8%A4%E9%83%A8%E5%88%86-%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E5%BE%88%E5%A5%BD%E7%9A%84%E6%80%9D%E8%B7%AF%E4%B8%8B%E9%9D%A2%E4%BC%9A%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E"><span class="toc-number">1.</span> <span class="toc-text">按照innodb的设计，文件存储的方式分为在内存和外存两部分。这是一个很好的思路，下面会详细说明。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98"><span class="toc-number">2.</span> <span class="toc-text">内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E5%AD%98"><span class="toc-number">3.</span> <span class="toc-text">外存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%9E%B6%E6%9E%84"><span class="toc-number">3.0.1.</span> <span class="toc-text">文件架构</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BAextent-%E6%98%AF%E6%AF%94%E9%A1%B5%E5%A4%A7%E4%B8%80%E7%BA%A7%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%9C%A8-innodb-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B8%AD%E4%B8%80%E4%B8%AA%E5%8C%BA%E4%BC%9A%E5%88%86%E9%85%8D-64-%E4%B8%AA%E8%BF%9E%E7%BB%AD%E7%9A%84%E9%A1%B5-innodb-%E4%B8%AD%E9%A1%B5%E5%A4%A7%E5%B0%8F%E9%BB%98%E8%AE%A4%E6%98%AF-16kb%E5%9B%A0%E6%AD%A4%E4%B8%80%E4%B8%AA%E5%8C%BA%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%98%AF6416kb"><span class="toc-number"></span> <span class="toc-text">区(Extent) 是比页大一级的存储结构，在 InnoDB 存储引擎中，一个区会分配 64 个连续的页。InnoDB 中页大小默认是 16KB，因此一个区的大小是 64 × 16 𝐾 𝐵</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#innodb-%E8%A7%84%E5%AE%9A%E7%9A%84%E6%9C%80%E5%B0%8F%E8%AE%B0%E5%BD%95%E4%B8%8E%E6%9C%80%E5%A4%A7%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9E%84%E9%80%A0%E5%8D%81%E5%88%86%E7%AE%80%E5%8D%95%E9%83%BD%E7%94%B1-5-%E5%AD%97%E8%8A%82%E7%9A%84%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF%E5%92%8C-8-%E5%AD%97%E8%8A%82%E5%A4%A7%E5%B0%8F%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9B%BA%E5%AE%9A%E7%9A%84%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90%E4%B8%80%E6%9D%A1%E5%8D%A058"><span class="toc-number"></span> <span class="toc-text">InnoDB 规定的最小记录与最大记录的构造十分简单，都由 5 字节的记录头信息和 8 字节大小的一个固定的部分组成（一条占 5 + 8</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%91-page_demo-%E8%A1%A8%E4%B8%AD%E5%86%8D%E5%A2%9E%E5%8A%A0-12-%E6%9D%A1%E8%AE%B0%E5%BD%95%E7%8E%B0%E5%9C%A8%E5%85%B1%E6%9C%89612"><span class="toc-number"></span> <span class="toc-text">向 page_demo 表中再增加 12 条记录，现在共有 6 + 12</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E4%B8%AD%E9%97%B4%E6%A7%BD%E7%9A%84%E4%BD%8D%E7%BD%AE%E4%B8%BA042"><span class="toc-number"></span> <span class="toc-text">计算中间槽的位置为 ( 0 + 4 ) ÷ 2</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#686%E8%AE%BE%E7%BD%AE-high-%E4%B8%BA-2low-%E4%BF%9D%E6%8C%81%E4%B8%8D%E5%8F%98%E9%87%8D%E6%96%B0%E8%AE%A1%E7%AE%97%E4%B8%AD%E9%97%B4%E6%A7%BD%E7%9A%84%E4%BD%8D%E7%BD%AE%E4%B8%BA022"><span class="toc-number"></span> <span class="toc-text">6 8&gt;6，设置 high 为 2，low 保持不变； 重新计算中间槽的位置为 ( 0 + 2 ) ÷ 2</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10221%E6%A7%BD-1-%E5%AF%B9%E5%BA%94%E7%9A%84%E4%B8%BB%E9%94%AE%E5%80%BC%E4%B8%BA-4%E5%8F%88%E5%9B%A0%E4%B8%BA4646%E8%AE%BE%E7%BD%AE-low-%E4%B8%BA-1high-%E4%BF%9D%E6%8C%81%E4%B8%8D%E5%8F%98%E7%94%B1%E4%BA%8Ehighlow"><span class="toc-number"></span> <span class="toc-text">1 (0+2)÷2&#x3D;1，槽 1 对应的主键值为 4，又因为 4 &lt; 6 4&lt;6，设置 low 为 1，high 保持不变； 由于 ℎ 𝑖 𝑔 ℎ − 𝑙 𝑜 𝑤</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A8%E8%A6%81%E5%8D%A0%E7%94%A8-2-%E4%B8%AA%E5%AD%97%E8%8A%82%E4%B8%94-c-%E5%88%97%E6%9C%AA%E8%A2%AB%E6%A0%87%E8%AE%B0%E4%B8%BA-not-null%E5%9B%A0%E6%AD%A4-null-%E5%80%BC%E5%88%97%E8%A1%A8%E8%BF%98%E4%BC%9A%E5%8D%A0%E7%94%A8-1-%E4%B8%AA%E5%AD%97%E8%8A%82%E6%9C%80%E7%BB%88%E8%87%AA%E8%83%BD%E5%88%9B%E5%BB%BA%E5%87%BA6553521"><span class="toc-number"></span> <span class="toc-text">变长字段长度列表要占用 2 个字节，且 c 列未被标记为 NOT NULL，因此 NULL 值列表还会占用 1 个字节，最终自能创建出 65535 − 2 − 1</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%8C%BA%E6%98%AF%E5%9C%A8%E7%89%A9%E7%90%86%E4%BD%8D%E7%BD%AE%E4%B8%8A%E8%BF%9E%E7%BB%AD%E7%9A%84-64%E4%B8%AA%E9%A1%B5-%E5%9B%A0%E4%B8%BA-innodb-%E4%B8%AD%E9%A1%B5%E7%9A%84%E5%A4%A7%E5%B0%8F%E9%BB%98%E8%AE%A4%E4%B8%BA-16kb%E6%89%80%E4%BB%A5%E4%B8%80%E4%B8%AA%E5%8C%BA%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%98%AF6416kb"><span class="toc-number"></span> <span class="toc-text">一个区是在物理位置上连续的 64个页。因为 InnoDB 中页的大小默认为 16KB，所以一个区的大小是 64 × 16 𝐾 𝐵</span></a></li></div></div></div><div class="sidebar-common-sidebar hidden"><div class="sidebar-author"><img data-src="/avatar/avatar.webp" data-sizes="auto" alt="mkitsdts" class="lazyload"><div class="sidebar-author-name">mkitsdts</div><div class="sidebar-description"></div></div><div class="sidebar-state"><div class="sidebar-state-article"><div>文章</div><div class="sidebar-state-number">12</div></div><div class="sidebar-state-category"><div>分类</div><div class="sidebar-state-number">0</div></div><div class="sidebar-state-tag"><div>标签</div><div class="sidebar-state-number">7</div></div></div><div class="sidebar-social"><div class="icon-email sidebar-social-icon"><a href="mkitsdts@outlook.com" itemprop="url" target="_blank" aria-label="email"></a></div><div class="icon-github sidebar-social-icon"><a href="https://github.com/mkitsdts" itemprop="url" target="_blank" aria-label="github"></a></div></div><div class="sidebar-menu"><div class="sidebar-menu-link-wrap"><a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a><div class="sidebar-menu-icon icon-taichi"></div><div class="sidebar-menu-link">首页</div></div><div class="sidebar-menu-link-wrap"><a class="sidebar-menu-link-dummy" href="/archives" aria-label="归档"></a><div class="sidebar-menu-icon icon-taichi"></div><div class="sidebar-menu-link">归档</div></div><div class="sidebar-menu-link-wrap"><a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a><div class="sidebar-menu-icon icon-taichi"></div><div class="sidebar-menu-link">关于</div></div><div class="sidebar-menu-link-wrap"><a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a><div class="sidebar-menu-icon icon-taichi"></div><div class="sidebar-menu-link">友链</div></div></div></div><div class="sidebar-btn-wrapper" style="position:static"><div class="sidebar-toc-btn current"></div><div class="sidebar-common-btn"></div></div></div></div></aside></div><footer id="footer"><div style="width:100%;overflow:hidden"><div class="footer-line"></div></div><div id="footer-info"><div><span class="icon-copyright"></span> 2023-2024 <span class="footer-info-sep"></span> mkitsdts</div><div>基于&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>&nbsp; Theme.<a href="https://github.com/D-Sketon/hexo-theme-reimu" target="_blank">Reimu</a></div><div><span class="icon-brush"></span> 24.7k &nbsp;|&nbsp; <span class="icon-coffee"></span> 01:25</div><div><span class="icon-eye"></span> <span id="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></span> &nbsp;|&nbsp; <span class="icon-user"></span> <span id="busuanzi_container_site_uv">总访客量&nbsp;<span id="busuanzi_value_site_uv"></span></span></div></div></footer><div class="sidebar-top"><img src="/images/taichi.png" height="50" width="50" alt="backtop"><div class="arrow-up"></div></div><div id="mask"></div></div><nav id="mobile-nav"><div class="sidebar-wrap"><div class="sidebar-toc-sidebar"><div class="sidebar-toc"><h3 class="toc-title">文章目录</h3><div class="sidebar-toc-wrapper toc-div-class"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%89%E7%85%A7innodb%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E5%88%86%E4%B8%BA%E5%9C%A8%E5%86%85%E5%AD%98%E5%92%8C%E5%A4%96%E5%AD%98%E4%B8%A4%E9%83%A8%E5%88%86-%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E5%BE%88%E5%A5%BD%E7%9A%84%E6%80%9D%E8%B7%AF%E4%B8%8B%E9%9D%A2%E4%BC%9A%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E"><span class="toc-number">1.</span> <span class="toc-text">按照innodb的设计，文件存储的方式分为在内存和外存两部分。这是一个很好的思路，下面会详细说明。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98"><span class="toc-number">2.</span> <span class="toc-text">内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E5%AD%98"><span class="toc-number">3.</span> <span class="toc-text">外存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%9E%B6%E6%9E%84"><span class="toc-number">3.0.1.</span> <span class="toc-text">文件架构</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BAextent-%E6%98%AF%E6%AF%94%E9%A1%B5%E5%A4%A7%E4%B8%80%E7%BA%A7%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%9C%A8-innodb-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B8%AD%E4%B8%80%E4%B8%AA%E5%8C%BA%E4%BC%9A%E5%88%86%E9%85%8D-64-%E4%B8%AA%E8%BF%9E%E7%BB%AD%E7%9A%84%E9%A1%B5-innodb-%E4%B8%AD%E9%A1%B5%E5%A4%A7%E5%B0%8F%E9%BB%98%E8%AE%A4%E6%98%AF-16kb%E5%9B%A0%E6%AD%A4%E4%B8%80%E4%B8%AA%E5%8C%BA%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%98%AF6416kb"><span class="toc-number"></span> <span class="toc-text">区(Extent) 是比页大一级的存储结构，在 InnoDB 存储引擎中，一个区会分配 64 个连续的页。InnoDB 中页大小默认是 16KB，因此一个区的大小是 64 × 16 𝐾 𝐵</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#innodb-%E8%A7%84%E5%AE%9A%E7%9A%84%E6%9C%80%E5%B0%8F%E8%AE%B0%E5%BD%95%E4%B8%8E%E6%9C%80%E5%A4%A7%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9E%84%E9%80%A0%E5%8D%81%E5%88%86%E7%AE%80%E5%8D%95%E9%83%BD%E7%94%B1-5-%E5%AD%97%E8%8A%82%E7%9A%84%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF%E5%92%8C-8-%E5%AD%97%E8%8A%82%E5%A4%A7%E5%B0%8F%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9B%BA%E5%AE%9A%E7%9A%84%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90%E4%B8%80%E6%9D%A1%E5%8D%A058"><span class="toc-number"></span> <span class="toc-text">InnoDB 规定的最小记录与最大记录的构造十分简单，都由 5 字节的记录头信息和 8 字节大小的一个固定的部分组成（一条占 5 + 8</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%91-page_demo-%E8%A1%A8%E4%B8%AD%E5%86%8D%E5%A2%9E%E5%8A%A0-12-%E6%9D%A1%E8%AE%B0%E5%BD%95%E7%8E%B0%E5%9C%A8%E5%85%B1%E6%9C%89612"><span class="toc-number"></span> <span class="toc-text">向 page_demo 表中再增加 12 条记录，现在共有 6 + 12</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E4%B8%AD%E9%97%B4%E6%A7%BD%E7%9A%84%E4%BD%8D%E7%BD%AE%E4%B8%BA042"><span class="toc-number"></span> <span class="toc-text">计算中间槽的位置为 ( 0 + 4 ) ÷ 2</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#686%E8%AE%BE%E7%BD%AE-high-%E4%B8%BA-2low-%E4%BF%9D%E6%8C%81%E4%B8%8D%E5%8F%98%E9%87%8D%E6%96%B0%E8%AE%A1%E7%AE%97%E4%B8%AD%E9%97%B4%E6%A7%BD%E7%9A%84%E4%BD%8D%E7%BD%AE%E4%B8%BA022"><span class="toc-number"></span> <span class="toc-text">6 8&gt;6，设置 high 为 2，low 保持不变； 重新计算中间槽的位置为 ( 0 + 2 ) ÷ 2</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10221%E6%A7%BD-1-%E5%AF%B9%E5%BA%94%E7%9A%84%E4%B8%BB%E9%94%AE%E5%80%BC%E4%B8%BA-4%E5%8F%88%E5%9B%A0%E4%B8%BA4646%E8%AE%BE%E7%BD%AE-low-%E4%B8%BA-1high-%E4%BF%9D%E6%8C%81%E4%B8%8D%E5%8F%98%E7%94%B1%E4%BA%8Ehighlow"><span class="toc-number"></span> <span class="toc-text">1 (0+2)÷2&#x3D;1，槽 1 对应的主键值为 4，又因为 4 &lt; 6 4&lt;6，设置 low 为 1，high 保持不变； 由于 ℎ 𝑖 𝑔 ℎ − 𝑙 𝑜 𝑤</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A8%E8%A6%81%E5%8D%A0%E7%94%A8-2-%E4%B8%AA%E5%AD%97%E8%8A%82%E4%B8%94-c-%E5%88%97%E6%9C%AA%E8%A2%AB%E6%A0%87%E8%AE%B0%E4%B8%BA-not-null%E5%9B%A0%E6%AD%A4-null-%E5%80%BC%E5%88%97%E8%A1%A8%E8%BF%98%E4%BC%9A%E5%8D%A0%E7%94%A8-1-%E4%B8%AA%E5%AD%97%E8%8A%82%E6%9C%80%E7%BB%88%E8%87%AA%E8%83%BD%E5%88%9B%E5%BB%BA%E5%87%BA6553521"><span class="toc-number"></span> <span class="toc-text">变长字段长度列表要占用 2 个字节，且 c 列未被标记为 NOT NULL，因此 NULL 值列表还会占用 1 个字节，最终自能创建出 65535 − 2 − 1</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%8C%BA%E6%98%AF%E5%9C%A8%E7%89%A9%E7%90%86%E4%BD%8D%E7%BD%AE%E4%B8%8A%E8%BF%9E%E7%BB%AD%E7%9A%84-64%E4%B8%AA%E9%A1%B5-%E5%9B%A0%E4%B8%BA-innodb-%E4%B8%AD%E9%A1%B5%E7%9A%84%E5%A4%A7%E5%B0%8F%E9%BB%98%E8%AE%A4%E4%B8%BA-16kb%E6%89%80%E4%BB%A5%E4%B8%80%E4%B8%AA%E5%8C%BA%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%98%AF6416kb"><span class="toc-number"></span> <span class="toc-text">一个区是在物理位置上连续的 64个页。因为 InnoDB 中页的大小默认为 16KB，所以一个区的大小是 64 × 16 𝐾 𝐵</span></a></li></div></div></div><div class="sidebar-common-sidebar hidden"><div class="sidebar-author"><img data-src="/avatar/avatar.webp" data-sizes="auto" alt="mkitsdts" class="lazyload"><div class="sidebar-author-name">mkitsdts</div><div class="sidebar-description"></div></div><div class="sidebar-state"><div class="sidebar-state-article"><div>文章</div><div class="sidebar-state-number">12</div></div><div class="sidebar-state-category"><div>分类</div><div class="sidebar-state-number">0</div></div><div class="sidebar-state-tag"><div>标签</div><div class="sidebar-state-number">7</div></div></div><div class="sidebar-social"><div class="icon-email sidebar-social-icon"><a href="mkitsdts@outlook.com" itemprop="url" target="_blank" aria-label="email"></a></div><div class="icon-github sidebar-social-icon"><a href="https://github.com/mkitsdts" itemprop="url" target="_blank" aria-label="github"></a></div></div><div class="sidebar-menu"><div class="sidebar-menu-link-wrap"><a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a><div class="sidebar-menu-icon icon-taichi"></div><div class="sidebar-menu-link">首页</div></div><div class="sidebar-menu-link-wrap"><a class="sidebar-menu-link-dummy" href="/archives" aria-label="归档"></a><div class="sidebar-menu-icon icon-taichi"></div><div class="sidebar-menu-link">归档</div></div><div class="sidebar-menu-link-wrap"><a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a><div class="sidebar-menu-icon icon-taichi"></div><div class="sidebar-menu-link">关于</div></div><div class="sidebar-menu-link-wrap"><a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a><div class="sidebar-menu-icon icon-taichi"></div><div class="sidebar-menu-link">友链</div></div></div></div></div><div class="sidebar-btn-wrapper"><div class="sidebar-toc-btn current"></div><div class="sidebar-common-btn"></div></div></nav></div><script src="https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js"></script><script src="https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js"></script><script src="/js/script.js"></script><script src="/js/aos.js"></script><script>var aosInit = () => {
      AOS.init({
        duration: 1000,
        easing: "ease",
        once: true,
        offset: 50,
      });
    };
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', aosInit);
    } else {
      aosInit();
    }</script><script src="/js/pjax_script.js" data-pjax></script><script type="module" data-pjax>import PhotoSwipeLightbox from "https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe-lightbox.esm.min.js";
  
  const pswp = () => {
    if (_$$('.article-entry a.article-gallery-item').length > 0) {
      new PhotoSwipeLightbox({
        gallery: '.article-entry',
        children: 'a.article-gallery-item',
        pswpModule: () => import("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.esm.min.js")
      }).init();
    }
    if(_$$('.article-gallery a.article-gallery-item').length > 0) {
      new PhotoSwipeLightbox({
        gallery: '.article-gallery',
        children: 'a.article-gallery-item',
        pswpModule: () => import("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.esm.min.js")
      }).init();
    }
    window.lightboxStatus = 'done';
    window.removeEventListener('lightbox:ready', pswp);
  }
  if(window.lightboxStatus === 'ready') {
    pswp()
  } else {
    window.addEventListener('lightbox:ready', pswp);
  }</script><script src="https://npm.webcache.cn/mouse-firework@0.0.4/dist/index.umd.js"></script><script>firework(JSON.parse('{"excludeElements":["a","button"],"particles":[{"shape":"circle","move":["emit"],"easing":"easeOutExpo","colors":["#ff5252","#ff7c7c","#ffafaf","#ffd0d0"],"number":20,"duration":[1200,1800],"shapeOptions":{"radius":[16,32],"alpha":[0.3,0.5]}},{"shape":"circle","move":["diffuse"],"easing":"easeOutExpo","colors":["#ff0000"],"number":1,"duration":[1200,1800],"shapeOptions":{"radius":20,"alpha":[0.2,0.5],"lineWidth":6}}]}'))</script><script src="https://npm.webcache.cn/quicklink@2.3.0/dist/quicklink.umd.js"></script><script data-pjax>quicklink.listen({timeout:3e3,priority:!0,ignores:[]})</script><div id="lazy-script"><div></div></div><script>console.log(String.raw`%c 
 ______     ______     __     __    __     __  __    
/\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
\ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
 \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
  \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                  
`,'color: #ff5252;')
    console.log('%c Theme.Reimu v' + '0.3.0' + ' %c https://github.com/D-Sketon/hexo-theme-reimu ', 'color: white; background: #ff5252; padding:5px 0;', 'padding:4px;border:1px solid #ff5252;')</script><script src="https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js" async></script><script>if ('serviceWorker' in navigator) {
    navigator.serviceWorker.getRegistrations().then((registrations) => {
      for (let registration of registrations) {
        registration.unregister();
      }
    });
  }</script><script src="/js/insert_highlight.js" data-pjax></script></body></html>